# Функция с переменным количеством аргументов
В программировании, если нам нужно выполнять похожие действия, мы определяем функции для многоразового использования кода. Чтобы выполнить это действие, мы вызываем функцию с определённым значением — аргументом.
Предположим, у нас есть функция, которая складывает три числа:
```python
def adder(x, y, z):
    print("sum:",x + y + z)
adder(10, 12, 13)
# sum: 35
```
Во фрагменте кода выше у нас есть функция `adder()` с тремя аргументами: `x, y` и `z`. При передаче трёх значений этой функции на выходе мы получаем их сумму. Но что, если передать больше трёх аргументов в эту функцию?
```python
def adder(x, y, z):
    print("sum: ",x + y + z)
adder(5, 10, 15, 20, 25)
```
Из-за того, что здесь мы передаём 5 аргументов, при запуске программы выводится ошибка `TypeError: adder() takes 3 positional arguments but 5 were given`.
## *args и **kwargs
В Python можно передать переменное количество аргументов двумя способами:
- `*args` для неименованных аргументов;
- `**kwargs` для именованных аргументов.
Мы используем `*args` и `**kwargs` в качестве аргумента, когда заранее не известно, сколько значений мы хотим передать функции.
### *args
Как было сказано, `*args` нужен, когда мы хотим передать неизвестное количество неименованных аргументов. Если поставить `*` перед именем, это имя будет принимать не один аргумент, а несколько
Аргументы доступны внутри функции под тем же именем, что и имя параметра, только без `*`. 
Например:
```python
def adder(*nums):
    sum = 0
    for n in nums:
        sum += n
    print("Sum: ", sum)
adder(3, 5)
# Sum: 8
adder(4, 5, 6, 7)
# Sum: 22
adder(1, 2, 3, 5, 6)
# Sum: 17
```
Здесь мы использовали `*nums` в качестве параметра, который позволяет передавать переменное количество аргументов в функцию `adder()`. Внутри функции мы проходимся в цикле по этим аргументам, чтобы найти их сумму, и выводим результат.
### **kwargs
По аналогии с `*args` мы используем kwargs для передачи переменного количества именованных аргументов. Схоже с `*args`, если поставить перед именем, это имя будет принимать любое количество именованных аргументов.
```python
def intro(**data):
    for key, value in data.items():
        print("{} is {}".format(key, value))
intro(Name="Alex", Age=22, Phone="0555-66-66-45")
# Name is Alex
# Age is 22
# Phone is 0555-66-66-45
intro(Name="Mary", Age=21, Phone="0777-11-22-33", Country="Kyrgyzstan", City="Bishkek")
# Name is Mary
# Age is 21
# Phone is 0777-11-22-33
# Country is Kyrgyzstan
# City is Bishkek
```
#### Что нужно запомнить:
- `*args` и `**kwargs` — специальный синтаксис, позволяющий передавать в функцию переменное количество аргументов. При этом, совсем не обязательно использовать имена аргументов `args` и `kwargs`;
- `*args` используется для неименованных аргументов, с которыми можно работать как со списком;
- `**kwargs` используется для именованных аргументов, с которыми можно работать как со словарём;

# Исключения в python. Конструкция try - except для обработки исключений

Исключения (exceptions) - ещё один тип данных в `python`. Исключения необходимы для того, чтобы сообщать программисту об ошибках.

Самый простейший пример исключения - деление на ноль:
```python
print(100 / 0)
# ZeroDivisionError: division by zero
```
Подсказки дают нам полную информацию о том, где порождено исключение, и с чем оно связано.

Рассмотрим иерархию встроенных в python исключений, хотя иногда вам могут встретиться и другие, так как программисты могут создавать собственные исключения.

![img](./img/hierarchy.png)
 

- `BaseException` - базовое исключение, от которого берут начало все остальные.
    - `SystemExit` - исключение, порождаемое функцией sys.exit при выходе из программы.
    - `KeyboardInterrupt` - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
    - `GeneratorExit` - порождается при вызове метода close объекта generator.
    - `Exception` - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
        - `StopIteration` - порождается встроенной функцией next, если в итераторе больше нет элементов.
        - `ArithmeticError` - арифметическая ошибка.
            - `FloatingPointError` - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
            - `OverflowError` - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
            - `ZeroDivisionError` - деление на ноль.
        - `AssertionError` - выражение в функции assert ложно.
        - `AttributeError` - объект не имеет данного атрибута (значения или метода).
        - `BufferError` - операция, связанная с буфером, не может быть выполнена.
        - `EOFError` - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
        - `ImportError` - не удалось импортирование модуля или его атрибута.
        - `LookupError` - некорректный индекс или ключ.
            - `IndexError` - индекс не входит в диапазон элементов.
            - `KeyError` - несуществующий ключ (в словаре, множестве или другом объекте).
        - `MemoryError` - недостаточно памяти.
        - `NameError` - не найдено переменной с таким именем.
            - `UnboundLocalError` - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
        - `OSError` - ошибка, связанная с системой.
            - `BlockingIOError`
            - `ChildProcessError` - неудача при операции с дочерним процессом.
            - `ConnectionError` - базовый класс для исключений, связанных с подключениями.
                - `BrokenPipeError`
                - `ConnectionAbortedError`
                - `ConnectionRefusedError`
                - `ConnectionResetError`
            - `FileExistsError` - попытка создания файла или директории, которая уже существует.
            - `FileNotFoundError` - файл или директория не существует.
            - `InterruptedError` - системный вызов прерван входящим сигналом.
            - `IsADirectoryError` - ожидался файл, но это директория.
            - `NotADirectoryError` - ожидалась директория, но это файл.
            - `PermissionError` - не хватает прав доступа.
            - `ProcessLookupError` - указанного процесса не существует.
            - `TimeoutError` - закончилось время ожидания.
        - `ReferenceError` - попытка доступа к атрибуту со слабой ссылкой.
        - `RuntimeError` - возникает, когда исключение не попадает ни под одну из других категорий.
        - `NotImplementedError` - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
        - `SyntaxError` - синтаксическая ошибка.
            - `IndentationError` - неправильные отступы.
                - `TabError` - смешивание в отступах табуляции и пробелов.
        - `SystemError` - внутренняя ошибка.
        - `TypeError` - операция применена к объекту несоответствующего типа.
        - `ValueError` - функция получает аргумент правильного типа, но некорректного значения.
        - `UnicodeError` - ошибка, связанная с кодированием / раскодированием unicode в строках.
            - `UnicodeEncodeError` - исключение, связанное с кодированием unicode.
            - `UnicodeDecodeError` - исключение, связанное с декодированием unicode.
            - `UnicodeTranslateError` - исключение, связанное с переводом unicode.
        - `Warning` - предупреждение.
        
Теперь, зная, когда и при каких обстоятельствах могут возникнуть исключения, мы можем их обрабатывать. Для обработки исключений используется конструкция `try - except`.

Первый пример применения этой конструкции:
```python
try:
    print(5/0)
except ZeroDivisionError:
    print("Нельзя делить на ноль")
# Нельзя делить на ноль
```
В блоке try мы выполняем инструкцию, которая может породить исключение, а в блоке except мы перехватываем их.
При этом перехватываются как само исключение, так и его потомки. Например, перехватывая ArithmeticError, мы также перехватываем FloatingPointError, OverflowError и ZeroDivisionError.

```python
try:
    print(5/0)
except ArithmeticError:
    print("Нельзя делить на ноль")
# Нельзя делить на ноль
```

Ещё две инструкции, относящиеся к нашей проблеме, это `finally` и `else`. `Finally` выполняет блок инструкций в любом случае, было ли исключение, или нет (применима, когда нужно непременно что-то сделать, к примеру, закрыть файл). Инструкция `else` выполняется в том случае, если исключения не было.

```python
try:
    print(5/0)
except ArithmeticError:
    print("Нельзя делить на ноль")
else:
    print("Ошибки нет, код успешно выполнен")
finally:
    print("Блок кода по окончанию всего, выполнится в любом случае")
```

## Создание исключения
При работе с исключениями программист тратит большую часть времени на обработку, но при этом возникают ситуации, когда исключениями надо и бросать в других.

"Бросить исключение" означает написать код, который при исполнении будет инициировать исключительную ситуацию.
```python
raise Exception("Текст исключения")
```

# Практика

- Напишите функцию `reverse_order` которая принимает любое количество строк и возвращает их в обратном порядке
- Напишите функцию `to_number` которая пытается строку перевести в число и вернуть, если эту строку нельзя перевести в число возвращает `False`
- Напишите функцию `number_sum` которая принимает любое количество чисел, складывает все числа, даже если числа были отправлены как строка
- Напишите функцию `animals_to_dict` которая принимает любое количество животных с именами и возвращает один словарь с этими значениями
- Напишите функцию `is_palindrome` которая проверяет является ли строка полиндромом. Палиндром — это слово или фраза, которые одинаково читаются слева направо и справа налево.
- Напишите функцию `file_extension` которая принимает имя файла и выводит его расширение. Если расширение у файла определить невозможно, выбросите исключение.
